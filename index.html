<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>A vs B Battle</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; /* スクロール防止 */
            touch-action: none; /* スマホでのブラウザバックなどを防止 */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 600px; /* PCでの最大幅 */
            background-color: #000;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #uiLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* ゲーム操作を邪魔しない */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud {
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }

        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: auto;
            text-align: center;
        }

        h1 {
            font-size: 48px;
            margin: 0 0 20px 0;
            color: #4facfe;
            text-transform: uppercase;
            letter-spacing: 4px;
        }

        p {
            font-size: 18px;
            margin-bottom: 30px;
            color: #ddd;
            line-height: 1.6;
        }

        button {
            background: linear-gradient(to right, #4facfe 0%, #00f2fe 100%);
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            color: white;
            border-radius: 30px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            font-weight: bold;
            text-transform: uppercase;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(79, 172, 254, 0.6);
        }

        button:active {
            transform: scale(0.95);
        }

        .hidden {
            display: none !important;
        }

        /* 画像読み込みステータス用 */
        #assetStatus {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 12px;
            color: #888;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 4px;
        }
        
        /* 警告メッセージ */
        .warning {
            color: #ffaa00;
            font-size: 14px;
            margin-top: 10px;
        }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    
    <div id="uiLayer">
        <div class="hud">SCORE: <span id="scoreDisplay">0</span></div>
        <div class="hud" style="color: #ff6b6b;">HP: <span id="hpDisplay">3</span></div>
    </div>

    <div id="startScreen">
        <h1>A vs B</h1>
        <p>A (味方) を操作して、<br>迫りくる B (敵) を撃て！<br><br>PC: マウス/矢印キー + クリック/スペース<br>スマホ: タッチ移動 + タップ</p>
        <button id="startButton">GAME START</button>
        <div id="assetStatus">Initializing...</div>
    </div>

    <div id="gameOverScreen" class="hidden">
        <h1 style="color: #ff6b6b;">GAME OVER</h1>
        <p>SCORE: <span id="finalScore">0</span></p>
        <button id="restartButton">RETRY</button>
    </div>
</div>

<script>
    // --- ゲーム設定と変数 ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const hpDisplay = document.getElementById('hpDisplay');
    const finalScoreDisplay = document.getElementById('finalScore');
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const startButton = document.getElementById('startButton');
    const restartButton = document.getElementById('restartButton');
    const assetStatus = document.getElementById('assetStatus');

    let animationId;
    let lastTime = 0;
    let score = 0;
    let gameActive = false;
    let difficultyMultiplier = 1;

    // 画像アセット管理
    // HTMLと同じフォルダに a.png と b.png を置いてください
    const assets = {
        player: { src: './a.png', img: new Image(), loaded: false, fallbackColor: '#4facfe', fallbackText: 'A' },
        enemy: { src: './b.png', img: new Image(), loaded: false, fallbackColor: '#ff6b6b', fallbackText: 'B' }
    };

    // 画像読み込み処理
    function loadAssets() {
        let loadedCount = 0;
        let errorCount = 0;
        
        assetStatus.textContent = "Loading images (a.png, b.png)...";

        const checkDone = () => {
            loadedCount++;
            if (loadedCount === 2) {
                if (errorCount > 0) {
                    assetStatus.innerHTML = "<span class='warning'>⚠️ 画像が見つかりません。<br>HTMLと同じ場所に a.png, b.png を置いてください。<br>仮の姿でゲームを開始します。</span>";
                } else {
                    assetStatus.textContent = "✅ Images loaded successfully!";
                    setTimeout(() => { assetStatus.style.display = 'none'; }, 2000);
                }
            }
        };

        for (const key in assets) {
            const asset = assets[key];
            asset.img.onload = () => {
                asset.loaded = true;
                console.log(`${key} image loaded successfully.`);
                checkDone();
            };
            asset.img.onerror = () => {
                asset.loaded = false;
                errorCount++;
                console.warn(`${key} image failed to load. Using fallback.`);
                checkDone();
            };
            asset.img.src = asset.src;
        }
    }

    // --- ゲームオブジェクト ---
    
    class Player {
        constructor() {
            this.width = 60;
            this.height = 60;
            this.x = canvas.width / 2 - this.width / 2;
            this.y = canvas.height - this.height - 20;
            this.speed = 400; // pixels per second
            this.hp = 3;
            this.isInvincible = false;
            this.invincibleTimer = 0;
        }

        update(deltaTime, input) {
            // マウス/タッチ追従モードの場合
            if (input.usePointer) {
                // ターゲット位置へスムーズに移動
                const targetX = input.x - this.width / 2;
                // 線形補間で滑らかに
                this.x += (targetX - this.x) * 0.2;
            } else {
                // キーボード操作
                if (input.left) this.x -= this.speed * deltaTime;
                if (input.right) this.x += this.speed * deltaTime;
            }

            // 画面端の制限
            if (this.x < 0) this.x = 0;
            if (this.x > canvas.width - this.width) this.x = canvas.width - this.width;

            // 無敵時間の処理
            if (this.isInvincible) {
                this.invincibleTimer -= deltaTime;
                if (this.invincibleTimer <= 0) {
                    this.isInvincible = false;
                }
            }
        }

        draw(ctx) {
            // 無敵時の点滅
            if (this.isInvincible && Math.floor(Date.now() / 100) % 2 === 0) return;

            if (assets.player.loaded) {
                ctx.drawImage(assets.player.img, this.x, this.y, this.width, this.height);
            } else {
                // フォールバック描画
                ctx.fillStyle = assets.player.fallbackColor;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 30px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(assets.player.fallbackText, this.x + this.width/2, this.y + this.height/2);
            }
        }

        hit() {
            if (this.isInvincible) return;
            this.hp--;
            this.isInvincible = true;
            this.invincibleTimer = 2; // 2秒無敵
            hpDisplay.textContent = this.hp;
            // 画面を赤くフラッシュさせる演出
            ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
    }

    class Bullet {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.width = 8;
            this.height = 20;
            this.speed = 600;
            this.markedForDeletion = false;
        }

        update(deltaTime) {
            this.y -= this.speed * deltaTime;
            if (this.y < -this.height) this.markedForDeletion = true;
        }

        draw(ctx) {
            ctx.fillStyle = '#00f2fe';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00f2fe';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.shadowBlur = 0;
        }
    }

    class Enemy {
        constructor() {
            this.width = 50;
            this.height = 50;
            this.x = Math.random() * (canvas.width - this.width);
            this.y = -this.height;
            // 難易度に応じて速度変化
            this.speedY = (Math.random() * 100 + 100) * difficultyMultiplier; 
            // 少し横に揺れる動き
            this.speedX = (Math.random() - 0.5) * 50;
            this.markedForDeletion = false;
            this.angle = 0;
            this.rotationSpeed = (Math.random() - 0.5) * 2;
        }

        update(deltaTime) {
            this.y += this.speedY * deltaTime;
            this.x += this.speedX * deltaTime;
            this.angle += this.rotationSpeed * deltaTime;

            if (this.x < 0 || this.x > canvas.width - this.width) this.speedX *= -1;

            if (this.y > canvas.height) {
                this.markedForDeletion = true;
                // 逃すと減点などは今回はなし
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            ctx.rotate(this.angle);

            if (assets.enemy.loaded) {
                ctx.drawImage(assets.enemy.img, -this.width / 2, -this.height / 2, this.width, this.height);
            } else {
                ctx.fillStyle = assets.enemy.fallbackColor;
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 30px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(assets.enemy.fallbackText, 0, 0);
            }
            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.size = Math.random() * 5 + 2;
            this.speedX = (Math.random() - 0.5) * 200;
            this.speedY = (Math.random() - 0.5) * 200;
            this.color = color;
            this.life = 0.5; // 秒
            this.markedForDeletion = false;
        }
        update(deltaTime) {
            this.x += this.speedX * deltaTime;
            this.y += this.speedY * deltaTime;
            this.life -= deltaTime;
            if (this.life <= 0) this.markedForDeletion = true;
        }
        draw(ctx) {
            ctx.globalAlpha = this.life * 2;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    // --- ゲーム管理 ---

    let player;
    let bullets = [];
    let enemies = [];
    let particles = [];
    let enemyTimer = 0;
    let enemyInterval = 1000;
    let input = { left: false, right: false, fire: false, x: 0, usePointer: false };

    function initGame() {
        resizeCanvas();
        player = new Player();
        bullets = [];
        enemies = [];
        particles = [];
        score = 0;
        difficultyMultiplier = 1;
        scoreDisplay.textContent = score;
        hpDisplay.textContent = player.hp;
        gameActive = true;
        lastTime = 0;
        input.x = canvas.width / 2; // 初期位置
        
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        
        animate(0);
    }

    function gameOver() {
        gameActive = false;
        finalScoreDisplay.textContent = score;
        gameOverScreen.classList.remove('hidden');
    }

    function createExplosion(x, y, color) {
        for (let i = 0; i < 10; i++) {
            particles.push(new Particle(x, y, color));
        }
    }

    function animate(timestamp) {
        if (!gameActive) return;
        
        const deltaTime = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        // リフレッシュレート変動対策
        if (deltaTime > 0.1) {
            animationId = requestAnimationFrame(animate);
            return;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // --- アップデート処理 ---

        // プレイヤー
        player.update(deltaTime, input);

        // 弾の発射（オート連射またはキー入力）
        // スマホの場合は常にオート連射気味に、PCならスペースキーなど
        // ここではシンプルに一定間隔で発射するロジックを簡略化して実装
        if (input.fire || input.usePointer) {
             // 簡易的な連射制限
             if (timestamp % 200 < 20) { // 大雑把なタイミング
                 // 実際にはタイマーを持つべきだが、今回は簡易実装
             }
        }

        // 弾の生成（入力があるときのみ、クールダウン管理）
        if (input.fire) {
             if (!player.lastShot || timestamp - player.lastShot > 200) {
                 bullets.push(new Bullet(player.x + player.width / 2 - 4, player.y));
                 player.lastShot = timestamp;
                 input.fire = false; // キー連打防止ならここでfalse、押しっぱなしなら処理を変える
             }
        }
        // タッチ操作時は自動で撃つのが快適
        if (input.usePointer) {
             if (!player.lastShot || timestamp - player.lastShot > 250) {
                 bullets.push(new Bullet(player.x + player.width / 2 - 4, player.y));
                 player.lastShot = timestamp;
             }
        }

        // 敵の生成
        enemyTimer += deltaTime * 1000;
        if (enemyTimer > enemyInterval) {
            enemies.push(new Enemy());
            enemyTimer = 0;
            // 時間経過で敵の出現頻度が上がる
            if (enemyInterval > 300) enemyInterval -= 5;
            difficultyMultiplier += 0.005;
        }

        // オブジェクト更新
        bullets.forEach(b => b.update(deltaTime));
        enemies.forEach(e => e.update(deltaTime));
        particles.forEach(p => p.update(deltaTime));

        // 削除フラグ回収
        bullets = bullets.filter(b => !b.markedForDeletion);
        enemies = enemies.filter(e => !e.markedForDeletion);
        particles = particles.filter(p => !p.markedForDeletion);

        // --- 当たり判定 ---
        
        // 弾 vs 敵
        bullets.forEach(bullet => {
            enemies.forEach(enemy => {
                if (!bullet.markedForDeletion && !enemy.markedForDeletion &&
                    rectIntersect(bullet.x, bullet.y, bullet.width, bullet.height,
                                  enemy.x, enemy.y, enemy.width, enemy.height)) {
                    bullet.markedForDeletion = true;
                    enemy.markedForDeletion = true;
                    score += 100;
                    scoreDisplay.textContent = score;
                    createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#ff6b6b');
                }
            });
        });

        // 敵 vs プレイヤー
        enemies.forEach(enemy => {
            if (!enemy.markedForDeletion && 
                rectIntersect(player.x + 10, player.y + 10, player.width - 20, player.height - 20, // 当たり判定少し小さく
                              enemy.x, enemy.y, enemy.width, enemy.height)) {
                enemy.markedForDeletion = true;
                player.hit();
                createExplosion(player.x + player.width/2, player.y + player.height/2, '#fff');
                
                if (player.hp <= 0) {
                    gameOver();
                }
            }
        });

        // --- 描画処理 ---
        player.draw(ctx);
        bullets.forEach(b => b.draw(ctx));
        enemies.forEach(e => e.draw(ctx));
        particles.forEach(p => p.draw(ctx));

        animationId = requestAnimationFrame(animate);
    }

    function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
        return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
    }

    function resizeCanvas() {
        const container = document.getElementById('gameContainer');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        if (player) {
            // リサイズ時にプレイヤーが画面外に行かないように
            if (player.y > canvas.height - player.height) player.y = canvas.height - player.height - 20;
        }
    }

    // --- イベントリスナー ---

    window.addEventListener('resize', resizeCanvas);

    // キーボード
    window.addEventListener('keydown', e => {
        if (e.code === 'ArrowLeft') input.left = true;
        if (e.code === 'ArrowRight') input.right = true;
        if (e.code === 'Space') input.fire = true;
        input.usePointer = false;
    });

    window.addEventListener('keyup', e => {
        if (e.code === 'ArrowLeft') input.left = false;
        if (e.code === 'ArrowRight') input.right = false;
        if (e.code === 'Space') input.fire = false;
    });

    // マウス / タッチ
    const handleMove = (x, y) => {
        const rect = canvas.getBoundingClientRect();
        input.x = x - rect.left;
        input.usePointer = true;
    };

    canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
    canvas.addEventListener('touchmove', e => {
        e.preventDefault(); // スクロール防止
        handleMove(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });

    canvas.addEventListener('mousedown', () => input.fire = true);
    canvas.addEventListener('mouseup', () => input.fire = false);
    canvas.addEventListener('touchstart', (e) => {
        handleMove(e.touches[0].clientX, e.touches[0].clientY);
        input.fire = true;
    }, { passive: false });
    canvas.addEventListener('touchend', () => input.fire = false);

    // ボタン
    startButton.addEventListener('click', initGame);
    restartButton.addEventListener('click', initGame);

    // 開始
    loadAssets();
    resizeCanvas();

</script>
</body>
</html>
